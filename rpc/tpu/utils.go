package tpu

import (
	"crypto/tls"
	"crypto/x509"
	"encoding/hex"
	"strconv"
	"strings"
)

func CheckIfDuplicate(array []string, item string) bool {
	for _, value := range array {
		if value == item {
			return true
		}
	}
	return false
}

func ConvertURLToWS(url string) string {
	urlWithReplacedProtocol := strings.Replace(strings.Replace(url, "https", "wss", -1), "http", "ws", -1)
	protocolSplit := strings.Split(urlWithReplacedProtocol, "://")
	if strings.Contains(protocolSplit[1], ":") {
		var port string = ""
		portSplit := strings.Split(protocolSplit[1], ":")
		if len(portSplit) == 2 {
			portInt, err := strconv.Atoi(strings.Replace(portSplit[1], "/", "", -1))
			if err != nil {
				return ""
			}
			port = strconv.Itoa(portInt + 1)
			return protocolSplit[0] + "://" + portSplit[0] + ":" + port
		} else {
			return ""
		}
	} else {
		return urlWithReplacedProtocol
	}
}

func createCertificate() ([]byte, []byte, error) {
	// seed := make([]byte, ed25519.SeedSize)
	// if _, err := io.ReadFull(rand.Reader, seed); err != nil {
	// 	return nil, nil, err
	// }
	// k := ed25519.NewKeyFromSeed(seed)
	PKCS8_PREFIX := []byte{
		0x30, 0x2e, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x04, 0x22, 0x04,
		0x20,
	}
	key_pkcs8_der := make([]byte, 0, len(PKCS8_PREFIX)+32)
	key_pkcs8_der = append(key_pkcs8_der, PKCS8_PREFIX...)
	secret, _ := hex.DecodeString("ffdfe513e1c35c36042c0784d101f328973811ebcdd20de55e1d15c1515c9752")
	key_pkcs8_der = append(key_pkcs8_der, secret...)
	cert_der := make([]byte, 0, 0xf4)
	cert_der = append(cert_der, []byte{
		0x30, 0x81, 0xf6, 0x30, 0x81, 0xa9, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x30, 0x16,
		0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0b, 0x53, 0x6f, 0x6c, 0x61,
		0x6e, 0x61, 0x20, 0x6e, 0x6f, 0x64, 0x65, 0x30, 0x20, 0x17, 0x0d, 0x37, 0x30, 0x30, 0x31,
		0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x18, 0x0f, 0x34, 0x30, 0x39, 0x36,
		0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30, 0x00, 0x30, 0x2a,
		0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x21, 0x00,
	}...)
	pubk, _ := hex.DecodeString("03678394c6069f399e99684499a6e924895cc801e12024cb5574fa85246ccd3b")
	cert_der = append(cert_der, pubk...)
	cert_der = append(cert_der, []byte{
		0xa3, 0x29, 0x30, 0x27, 0x30, 0x17, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x01, 0x01, 0xff, 0x04,
		0x0d, 0x30, 0x0b, 0x82, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0x30,
		0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x02, 0x30, 0x00, 0x30, 0x05,
		0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x41, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}...)
	return cert_der, key_pkcs8_der, nil
}

func CreateTlsCertificate() (tls.Certificate, error) {
	cert, k, err := createCertificate()
	if err != nil {
		return tls.Certificate{}, err
	}
	key, err := x509.ParsePKCS8PrivateKey(k)
	if err != nil {
		return tls.Certificate{}, err
	}
	return tls.Certificate{
		Certificate: [][]byte{cert},
		PrivateKey:  key,
	}, nil
}
